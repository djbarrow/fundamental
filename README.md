# What is fundamental



Fundamental is a c command line program, a rough diamond which barely works beautifully but is my most original program to date. I've recently found out that it uses a technique called [Symbolic Regression](https://en.wikipedia.org/wiki/Symbolic_regression). It is also being marketed as Dirac because it has the inhuman talent of Dirac the famous Relativistic Detached almost Autistic Strange Genius Feynmans hero to pull inhuman crazy equations out of the air which fit data better than curve fitting, it can curve fit a sin x yes it can!!!!!, primative traditional polynomial curve fitting can't.

There was code checked in around march 17th 2023 which could find loops if your forking the code to fix bugs take this code too its buggy & doesn't work but its more advanced about 30% extra code. It also does successive apporoximation a type of genetic algorithm this code might have bugs too.

It found a formula for the smallest factor in a composite number the in project https://www.github.com/djbarrow/find_smallest_factor.git. This might help crack rsa the bank encryption scheme My program fundamental found a way to get the smallest factor of a number However I need more memory than atoms in the universe to complete the job for 2048 bit rsa it's limited at the moment to 2^31 on an 8GB ram machine. The result may be linked to fermats primality test to unzip the source tar -zxpvf find_smallest_factor.tgz I don't think I will crack rsa but it's a new approach and might lead to something with a better mathematician than me.

I always believed rsa could be cracked on a zx spectrum Seeing as the did a differential question answer differential equation of the entire knowledge of google with sentence and paragraph attention in chatgpt rsa now looks like low hanging fruit. Now I might be closer.

To protect banks I advise the following scheme Multiple encryption - Wikipedia

I made an attempt at genetic programming/successive approximation in the process_fundamental related functions,
I am unsure of the quality of this code due to mental health problems unfortunately im 56 now and code
i wrote 20 years ago isn't easy to fix or understand and my mental health problems started 20 years ago
I feel like Terry A Davis of templeos.org fame, I'm getting old I wish I wasn't, cest la vie.

A YouTube video of the program running can be found here https://youtu.be/sD-pk9Pt4-Y

The potential discoveries made by the program so far are as follows...
I include 2 constants 2^1/12 the distance between semitones and the golden ratio.
These constants are small and potentially can create the semi miraculous equations here without being
miracolous at all I can only assume 1 in 10 any of these equations is significant.
The reason i included semitones is string theory is 12 dimensional and so is western music an octave is 12 semitones.
also people who have near death experiences say music is everywhere in heaven so i thought the quantity could
be interesting see sidroth.org and iands.org for more info about peoples visits to heaven.
However on thinking about it because the mass of neutron almost equals the mass of the proton  the mass of electron being very close einsteins theory of relativity kindof implys mass of neutron = mass of proton + electron
to the dufference the fix of to get this more accutate to one in a thousand is about 1.6 times the mass of the electron this is an
easy factor to come up with any number near 1.5 will do so these results I unfortunately for me think are an easy fluke.

Found match error=4.714556e-05 fundamental constant name=mass_of_neutron value=1.674929e-27
result=1.675008e-27
mass_of_proton mass_of_electron mass_of_electron golden_ratio  *  +  + 
1.672623e-27 9.109390e-31 9.109390e-31 1.618034e+00  *  +  + 
(mass_of_proton + (mass_of_electron + (mass_of_electron * golden_ratio)))
(1.672623e-27  + (9.109390e-31  + (9.109390e-31  * 1.618034e+00 )))

Found match error=7.948149e-05 fundamental constant name=mass_of_neutron value=1.674929e-27
result=1.675062e-27
mass_of_proton mass_of_electron golden_ratio semitone_multiple  +  *  + 
1.672623e-27 9.109390e-31 1.618034e+00 1.059463e+00  +  *  + 
(mass_of_proton + (mass_of_electron * (golden_ratio + semitone_multiple)))
(1.672623e-27  + (9.109390e-31  * (1.618034e+00  + 1.059463e+00 )))

Found match error=4.818072e-05 fundamental constant name=semitone_multiple value=1.059463e+00
result=1.059412e+00
1 fine_structure_constant 5 pi  +  *  + 
1 7.297350e-03 5 3.141593e+00  +  *  + 
(1 + (fine_structure_constant * (5 + pi)))
(1 + (7.297350e-03  * (5 + 3.141593e+00 )))

Found match error=9.784477e-05 fundamental constant name=mass_of_proton value=1.672623e-27
result=1.672459e-27
mass_of_neutron mass_of_electron fine_structure_constant e  -  *  + 
1.674929e-27 9.109390e-31 7.297350e-03 2.718282e+00  -  *  + 
(mass_of_neutron + (mass_of_electron * (fine_structure_constant - e)))
(1.674929e-27  + (9.109390e-31  * (7.297350e-03  - 2.718282e+00 )))

Found match error=8.134724e-05 fundamental constant name=mass_of_proton value=1.672623e-27
result=1.672759e-27
mass_of_neutron mass_of_electron golden_ratio 4  -  *  + 
1.674929e-27 9.109390e-31 1.618034e+00 4  -  *  + 
(mass_of_neutron + (mass_of_electron * (golden_ratio - 4)))
(1.674929e-27  + (9.109390e-31  * (1.618034e+00  - 4)))

Found match error=4.310236e-05 fundamental constant name=semitone_multiple value=1.059463e+00
result=1.059509e+00
1 3 e fine_structure_constant  *  *  + 
1 3 2.718282e+00 7.297350e-03  *  *  + 
(1 + (3 * (e * fine_structure_constant)))
(1 + (3 * (2.718282e+00  * 7.297350e-03 )))

Found match error=1.222877e-05 fundamental constant name=mass_of_neutron value=1.674929e-27
result=1.674909e-27
mass_of_proton mass_of_electron mass_of_muon fine_structure_constant  *  +  + 
1.672623e-27 9.109390e-31 1.883532e-28 7.297350e-03  *  +  + 
(mass_of_proton + (mass_of_electron + (mass_of_muon * fine_structure_constant)))
(1.672623e-27  + (9.109390e-31  + (1.883532e-28  * 7.297350e-03 )))

Found match error=4.892766e-05 fundamental constant name=mass_of_neutron value=1.674929e-27
result=1.674847e-27
mass_of_proton mass_of_muon golden_ratio fine_structure_constant  *  *  + 
1.672623e-27 1.883532e-28 1.618034e+00 7.297350e-03  *  *  + 
(mass_of_proton + (mass_of_muon * (golden_ratio * fine_structure_constant)))
(1.672623e-27  + (1.883532e-28  * (1.618034e+00  * 7.297350e-03 )))

Found match error=4.899031e-05 fundamental constant name=mass_of_proton value=1.672623e-27
result=1.672705e-27
mass_of_neutron mass_of_muon golden_ratio fine_structure_constant  *  *  - 
1.674929e-27 1.883532e-28 1.618034e+00 7.297350e-03  *  *  - 
(mass_of_neutron - (mass_of_muon * (golden_ratio * fine_structure_constant)))
(1.674929e-27  - (1.883532e-28  * (1.618034e+00  * 7.297350e-03 )))

Firstly have a look at potential_physics_discoveries.txt for discoveries check the equations from a physics standpoint are dimensionally correct the ones inolving e mass of proton neutron and electron and the golden ratio and fine structure constant are especially interesting.

NEW FEATURE
Fundamental can now find the formula of a field entered as individual points in a csv file of NUM_REAL_DIMENSIONS
e.g.

1,2,0,3

0,2,3,5

0,3,2,5

4,5,0,9

The first 3 values in this field are x,y,z coordinates the last value is the field value will yield the formula
n[0]+(n[1]+n[2])

Fundamental is a toolbox for finding relationships between

*   numbers, e.g. is there any relationship between the numbers PI, e, the square root of 2?
*   sequences of numbers, e.g. the sequence 2, 4, 6, 8, 10, ... It could replace/compliment this [encylopedia of integer sequences (OEIS)](http://oeis.org/) website.

It could have found the following formulas which started quantum physics had it been around in the 1860's & 1890's. [Balmer Series](http://www.colorado.edu/physics/2000/quantumzone/balmer.html)  

It could have found [Planck's Law](http://en.wikipedia.org/wiki/Planck%27s_law) if on a supercomputer or used SETI at home's computer network.  

It could with some improvements in pattern matching have found Mendeleev's periodic table of elements or did some of Murray Gell Mann's work for which he got a Nobel Prize in 1969 for developing the Standard Model in Physics.

In short it's for hacking the laws of nature & mathematics

it is in some ways related to curve fitting ( or more percisely a program for finding integer relations ) where you have some data & are looking for a formula to describe it, curve fitting can usually be done by a human, fundamental is more a brute force method where you tell fundamental what operators are allowed + - x / bitwise and or etc. The constants, e PI, it starts with the most simple sums & progresses towards the more complex.

My original motivation for writing it was while reading Max Borns book on the theory or relativity I fell over a fantastic insight one of Maxwells equations.  

<center>sqrt(permability of material*permittivity of material ) = speed of light.  
</center>

They didn't at the time know that light was electromagnetic radiation. What I fell over was that there were redundant constants of physics & if a program mas made to search for interrelations between the constants of physics on might by brute force find redundancies, simplifications & potentially new laws of of physics, I was onto a winner which I knew I could pull off. I had the first prototype of "Fundamental" laws of Physics written in 36 hours around 300 lines of code. It found existing laws of physics but no new ones.

It uses reverse polish notation (RPN) explained [here along with some explanations of the internals of fundamental not covered anywhere else](http://sinscienceandspirituality.blogspot.ie/2018/05/the-joys-of-reverse-polish-notation.html), the beauty of reverse polish notation is that there is no need for brackets the sum 2+3x2=8 or 10 depending on whether you interpret the sum as (2+3)x2 or 2+(3x2) reverse polish notation gets us out of this bind because the order of the numbers & operators gaurantees a unique & unambiguous algorithmic way to do the sum. It also makes it very easy to sequence or "count" through legal sums algorithmically & be gauranteed that each sum is unique.  
e.g.  
2+3 is an illegal RPN sum as the + binary operator needs 2 numbers to its left.  
2 3 + in RPN is equal to 5.

This is the beautiful idea which made funamental possible. The only conditions you need to make in RPN to do any equation is that there needs to be one less binary operator than numbers in the equation. The first binary must have at least 2 numbers to it's left A unary operatior has to have at least 1 number to its left

e.g.  
5 ! ! ! 2 3 + 5 + + is a legal sum ! being the factorial unary operator.

Also the equations generated using RPN are easily countable. e.g. it is easily algorithmically possible to write a program for every possible RPN equation with constraints. ( an example of constraints are only numbers between 0 and 5 are allowed & only the + & * operators are allowed * being the multiplication operator.

One of the thing I've had no success with fundamental is finding a formula for the nth prime, primality testing & pulling out the smallest or largest factor from a very big number.

Fundamental is a step towards automatic algorithm generation. I am very proud of Fundamental & have great hopes for it, it's by far my best idea to date,

Although my program doesn't use genetic algorithms, it brute force searches a solution space of RPN sums, however, it can be configured to use successive approximation (I read about genetic programming before inventing fundamental and I'm sure i got inspired by wondering how data mining works).  My program is almost identical in functionality to Eureqa & I am sure can find sums Eureqa can't as Eureqa calculates fitnesses of guesses & tries to find genetically fitter answers which won't work in cases where fundamental will,if I'm doing a bad job at explaining how fundamental works please watch [the following beautiful videos of Eureqa](http://formulize.nutonian.com/documentation/eureqa/). [A Isralei professors Eureqa moment.](http://www.haaretz.com/israel-news/an-israeli-professor-s-eureqa-moment-1.410881) Tony also has some code written but his [open source eureqa](https://github.com/verdverm) seems too simple to be as mature as fundamental, it is designed for paralell processing something yet to be done in fundamental. Tony also implemented [PGE](https://www.lri.fr/~hansen/proceedings/2013/GECCO/proceedings/p1021.pdf) but in python which means it would be slow. One last link for reference [Quora thread for alternatives to Eureqa](https://www.quora.com/Are-there-any-good-alternatives-to-Nutonian-Eureqa-Formulize-for-curve-fitting), [here is the deep learning approach to curve fitting](http://neuralnetworksanddeeplearning.com/chap4.html)

It's open source & I hope someday it will help someone solve significant problems, if it does please give me some credit for helping you on your way. It may be of use in Mathematics, Chemistry, Physics & Economics for Modeling data without a known formula. The program could be enhanced to do automatic algorithm generation using an open source forth language engine like Paflof or else Java bytecode. however it will be about 20 years before computation speeds will make this possible. Here is a description of what it how it works & what it currently does.

Fundamental internally uses reverse polish notation algorithm to search a solution space for a formula given test data, it can search for formulas for sequences of numbers as well as relationships between constants. To date it was successfully able to find the following by a brute force solution space search for..  
generate the [Taylor Series for e(x)](http://en.wikipedia.org/wiki/Taylor_series)  
An estimate formula for the nth prime.  
Design an n bit adder using only boolean logic.  
It could have found the formula for the Balmier lines in the hydrogen spectrum

[The Miraculous Bailey-Borwein-Plouffe Pi Algorithm](http://en.wikipedia.org/wiki/Bailey%E2%80%93Borwein%E2%80%93Plouffe_formula) [Borweins Algorithm](http://en.wikipedia.org/wiki/Borwein's_algorithm) was found by a similar ( but fundamentally much different ) program.

## Example

When set up properly you can enter a sequence like  
5,8,11,14,17 as follows  
fundamental -h 5 -m 5 -i 5 5 8 11 14 17  
Setting -h to 5 sets the maximum integer in the solution space to 5.  
Setting -m to 5 sets the stack depth or the maximum complexity of the sum to 5 term.  
Setting -i to 5 tells fundamental that there are 5 terms following which contain the sequence.  
The output of the testrun is:  
5 3 n[0] * +  
(5 + (3 * n[0]))  
5 -3 -n[0] * +  
(5 + (-3 * -n[0]))  
So the sequence formula is y=f(n[0])=5+(3 x n[0]), n[0] being an integer. 

## Accolades & Delusions of Grandeur ;)

### Pio a Friend and Fundamental

Pio is a bright guy, speaks 5 languages, Degree in numerical computation & mathematics currently doing a hdip in cloud computing. I've been 6 years trying to convince Pio that Fundamental was more than curve fitting. After reading Carsten Otte's compliment he decided he'd better investigate himself. Now he's spouting things like GO FOR IT!!, Smart Cookie D.J., uv cracked it this time D.J. Google can't help but buy it. Now he is in disbelief that nothing like it has ever been done before. Stuart Russell & [Peter Norvig](http://norvig.com) <a>in Artificial Intelligence a modern approach hint that it can be done but is totally impractical, my program proves otherwise. Pio has agreed to write a fisher price web interface for fundamental & explore data mining possibilities which he is learning in the cloud computing course.... Thanks Pio.</a>

<a>

A colleage at Pace in West Yorkshire who knew Richard Feynman personally said Fundamental was bloody useful.

A colleague at IBM Boeblingen Carsten Otte had this to say...  
I browsed through the code of fundamental a bit.  
I find the idea brilliant, and I think this might be worth drilling deeper.  

</a>
<a>
 Andrea said this after examining the code and me fixing a minor bug to get it going for him.
Hello D.J.
sorry for the long time to answer...
i have had too many argument to study to understand well that ,,,
I think your work it's absolutely fabulous !
</a>

<a></a>[Fabrice Bellard](http://en.wikipedia.org/wiki/Fabrice_Bellard) <a>didn't directly sing it's praises but here is what he'd to say  
Someone told me about a similar project some time ago and I find the idea interesting. Of course the problem is to limit the exponential growth of the search space. I guess that an exhaustive search cannot lead to very interesting discoveries because the programs are too small. But there may be ways to explore a subspace of the "interesting" possible programs with a well chosen language and search algorithm.</a>

<a></a>

<a>I guess that you already know the</a> [PSLQ algorithm](http://en.wikipedia.org/wiki/Integer_relation_algorithm) [( very intersting pdf here on the topic )](http://arminstraub.com/files/pslq.pdf)used to find the BBP Pi formula you mention. It just finds a linear combination with small integer coefficients of constants giving a zero result. It is very limited but already quite effective to find interesting relations.

Most importantly is only 2k lines of code.  

This is not curve fitting as defined by Wikipedia, curve fitting can be done using pen & paper & it gauranteed to produce an answer for the class of problems it solves, fundamental typically does billions of calculations when used for curve fitting without gaurantee of an answer & can handle classes of problems not handleable by traditional curve fitting or Mathematica.

## Caveats

Yes the code is buggy if you aren't acquainted with the gdb debugger now is the time to get familiar, the code compiles using gcc & runs on Linux & possibly Cygwin for Windows.

The section of the code enabled loops ( e.g. needed to find the Taylor series expansion formula for e(x) ) by the MAX_NUM_LOOPVARS is hopelessly broken, don't use it & #ifdef it out, I'm currently rewriting fundamental so that it can develop code automatically for things like bubblesorts automatically rather than just the rather limited loop.

## Documentation

Fundamental now contains a Fundamental Overview.doc readme explaining most of the internals of fundamental, please feel welcome to send questions to me at barrow_dj@yahoo.com and I will add detail to the document explaining your concern.

P.S. Remember gdb is your friend when pulling out bugs use it you can call print_sum directly from the debugger to see how the sum trials are progressing.

Please also look at github feynman.ai and their website it is more advanced in ways, feynman.ai code is in python I thought it was slow but it uses pytorch gpu magic I'm unsure if my code beats it python 100x slower vs gpu 100x faster, my code is tight pre processed C unthreaded and un networked, I like my code because its mine but this goes further than my code does in ambition. feynman.ai has dimensional analysis which I'm jealous of, it does more than my code for physics formula finding I wonder if the github feynman.ai does all it claims there isn't much code in the project and doing it in python rather than cython implys crapware, try merging the tidiest of my code with this. Also look at cern data files and jupiler note books and see if something in physics can be discovered. Nope my code doesn't have rpn to pytorch requiring a nvidia gpu most likely, feynman.ai is superior but it may have stolen the rpn idea from my code, I hope it did I got almost 3000
readers of the joys of rpn in my sinscienceandspirituality.blogspot.com lets hope i was the origin of inspiring this code by the way symbolic regression was invented in 1975 which my code is a legacy of those who had similar ideas before me. My code was the best i could do i have to accept better now has been done.

eureqa code is commercial and similar to my code slightly tidier as a commercial offering but feynman.ai is extremely interesting for physics. Tony Worm IBM github wrote a bloated java version of my code completely independently his pdf documenting his ideas is better than mine and will provide additional education for you java code java is 10x slower than c, and i use the c preprocessor to make my code more than 20x faster i basically #ifdef out unwanted code. A princeton doctorate looked at my code and did something interesting in julia with more distributed computing support google github symbolic regression princeton.

The successive approximation/genetic algorithm HAVE_ERROR_MEASURMENTS is incomplete just leave it out of fundamental_config.h

## More about the Author
I am a Christian, & I thank God for inspiring this code, my blog business card can be found here https://djbarrow.blogspot.com/2021/03/about-me_13.html and a Take on The Theory of everything can be found here https://sinscienceandspirituality.blogspot.com/2020/12/interesting-factoids-and-limitationsin.html
